//    void resizeDown() {
//        int new_capacity = std::max(DEFAULT_CAPACITY, capacity / 2);
//        unique_ptr<shared_ptr<Tree<T>>[]> newTable(new shared_ptr<Tree<T>>[new_capacity]());
//
//        for(int i = 0; i < new_capacity; i++) {
//            newTable[i] = make_shared<Tree<T>>();
//        }
//
//        // TODO: add try catch block here
//        auto arr = new shared_ptr<T>[size];
//        int index = 0;
//        for(int i = 0; i < capacity; i++){ // O(capacity) time complexity
//            if(table[i]->getSize() == 0) continue;
//            auto temp = table[i]->returnSortedArrayOfElements(); // works in O(n_of_team_i) time complexity
//            for(int j = 0; j < table[i]->getSize(); j++){ // O(n_of_team_i) time complexity
//                arr[index] = temp[j];
//                index++;
//            }
//            delete[] temp;
//        }
//
//        if(index != size) {
//            cerr << "index: " << index << " size: " << size << endl;
//            throw std::runtime_error("index is not equal to size");
//        }
//
//        capacity = new_capacity; // changing the rehash function
//
//        for(int i = 0; i < index; i++) {
//            int hashed_index = hash(arr[i]->getID());
//            newTable[hashed_index]->insert(arr[i]);
//        }
//
//        delete[] arr;
//        table = std::move(newTable);
//    }


//    void resizeUp(){
//        int new_capacity = capacity * 2 + 1;
//        unique_ptr<shared_ptr<Tree<T>>[]> newTable(new shared_ptr<Tree<T>>[new_capacity]());
//
//        for(int i = 0; i < new_capacity; i++){
//            newTable[i] = make_shared<Tree<T>>();
//        }
//        // TODO: add try catch block here
//        auto arr = new shared_ptr<T>[size];
//
//        int index = 0;
//        for(int i = 0; i < capacity; i++){ // O(capacity) time complexity
//            if(table[i]->getSize() == 0) continue;
//            auto temp = table[i]->returnSortedArrayOfElements(); // works in O(n_of_team_i) time complexity
//            for(int j = 0; j < table[i]->getSize(); j++){ // O(n_of_team_i) time complexity
//                arr[index] = temp[j];
//                index++;
//            }
//            delete[] temp;
//        }
//
//        capacity = new_capacity; // changing the rehash function
//
//        if(index != size) {
//            cerr << "index: " << index << " size: " << size << endl;
//            throw std::runtime_error("index is not equal to size");
//        }
//        for(int i = 0; i < index; i++){
//            int hashed_index = hash(arr[i]->getID());
//            newTable[hashed_index]->insert(arr[i]);
//        }
//        delete[] arr;
//        table = std::move(newTable);
//    }